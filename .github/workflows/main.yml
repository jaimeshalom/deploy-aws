name: Deploy NestJS on ECR

on:
  push:
    tags:
      - 'v*.*.*'    # Tags como v1.2.3
      - '*.*.*'      # Tags como 1.2.3
    # branches:
    #   - main

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: marduk/ari-integration
  ECS_SERVICE: ari-integration-service
  ECS_CLUSTER: ari-integration-cluster
  ECS_TASK_DEFINITION: ari-integration-task-definition
  CONTAINER_NAME: ari-integration-container
  NODE_VERSION: '22'

jobs:
  test-and-lint:
    name: Test and Lint
    runs-on: ubuntu-latest
    services:
      mongo:
        image: mongo:6.0.2
        ports:
          - 27017:27017
        # --- Añadir Healthcheck Básico al Servicio ---
        # Esto le dice a Docker que espere hasta que el comando tenga éxito
        # antes de considerar el servicio "saludable". Aunque Actions no
        # lo use directamente para esperar, es buena práctica.
        options: >-
          --health-cmd "mongosh --eval 'db.runCommand(\"ping\").ok' --quiet"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        # --- Fin Healthcheck ---
    steps:
      - name: Check semantic tag format
        run: |
          TAG_NAME=${GITHUB_REF#refs/tags/}
          if [[ ! "$TAG_NAME" =~ ^v?[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "❌ El tag $TAG_NAME no es una versión semántica (ej: v1.0.0 o 2.3.4)"
            exit 1
          fi
          echo "✅ Tag válido: $TAG_NAME"

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Wait for MongoDB
        run: |
          echo "Waiting for MongoDB to start..."
          i=0
          # Intenta conectar al puerto 27017 de localhost hasta 30 veces
          until nc -z localhost 27017; do
            i=$((i+1))
            if [ $i -ge 30 ]; then
              echo "$(date) - MongoDB service timed out."
              exit 1
            fi
            echo "$(date) - Waiting for MongoDB service... ($i/30)"
            sleep 1
          done
          echo "MongoDB started!"

      - name: Run linter
        run: npm run lint

      - name: Run tests
        run: npm run test

      - name: Run e2e tests
        env:
          MONGODB_URI: mongodb://localhost:27017/test_db
        run: npm run test:e2e

  create-docker-image:
    name: Build and Push Image
    runs-on: ubuntu-latest
    needs: test-and-lint
    outputs:
      image: ${{ steps.build-push.outputs.image }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build, tag, and push image with multiple tags
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          GIT_BRANCH: ${{ github.ref_name }}  # Nombre del branch o tag
          IS_TAG_EVENT: ${{ startsWith(github.ref, 'refs/tags/') }}  # True si es un tag
        run: |
          # Sanitización de nombres para Docker (solo caracteres permitidos)
          SANITIZED_BRANCH=$(echo "$GIT_BRANCH" | tr -cd '[:alnum:]-._' | sed 's/^[.-]*//' | cut -c 1-50)
          COMMIT_SHA_SHORT=${{ github.sha | substr(0,20) }}

          # Tags principales
          BASE_TAG="$ECR_REGISTRY/$ECR_REPOSITORY"
          TAG_SHA="$BASE_TAG:$COMMIT_SHA_SHORT"
          TAG_BRANCH="$BASE_TAG:$SANITIZED_BRANCH"

          # Tag adicional si es un evento de tag de Git
          if [ "$IS_TAG_EVENT" = "true" ]; then
            GIT_TAG=$(echo "$GIT_BRANCH" | sed 's/^v//')  # Remueve prefijo 'v' si existe
            TAG_VERSION="$BASE_TAG:$GIT_TAG"
            docker build -t $TAG_SHA -t $TAG_BRANCH -t $TAG_VERSION .
            docker push $TAG_VERSION  # Pushear el tag de versión explícitamente
          else
            docker build -t $TAG_SHA -t $TAG_BRANCH .
          fi

          # Pushear todos los tags
          docker push $TAG_SHA
          docker push $TAG_BRANCH

          # Output para el job de deploy (usamos el SHA como referencia única)
          echo "image=$TAG_SHA" >> $GITHUB_OUTPUT

  deploy:
    name: Deploy to ECS
    runs-on: ubuntu-latest
    needs: create-docker-image
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Download task definition
        run: |
          aws ecs describe-task-definition --task-definition ${{ env.ECS_TASK_DEFINITION }} --query taskDefinition > task-definition.json

      - name: Fill in the new image ID in the Amazon ECS task definition
        id: task-def
        uses: aws-actions/amazon-ecs-render-task-definition@v1
        with:
          task-definition: task-definition.json
          container-name: ${{ env.CONTAINER_NAME }}
          image: ${{ needs.create-docker-image.outputs.image }}

      - name: Deploy Amazon ECS task definition
        uses: aws-actions/amazon-ecs-deploy-task-definition@v1
        with:
          task-definition: ${{ steps.task-def.outputs.task-definition }}
          service: ${{ env.ECS_SERVICE }}
          cluster: ${{ env.ECS_CLUSTER }}
          wait-for-service-stability: true