name: Deploy NestJS on ECR

on:
  push:
    tags:
      - 'v*.*.*'    # Tags como v1.2.3
      - 'v*.*.*.*'    # Tags como v1.2.3.4
    # branches:
    #   - main

env:
  ECR_REPOSITORY: ${{ vars.PROJECT_NAME }}-${{ vars.ENVIRONMENT }}-ecr_repository

jobs:
  test-and-lint:
    name: Test and Lint
    runs-on: ubuntu-latest
    services:
      mongo:
        image: mongo:6.0.2
        ports:
          - 27017:27017
        options: >-
          --health-cmd "mongosh --eval 'db.runCommand(\"ping\").ok' --quiet"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    steps:
      - name: Check semantic tag format
        run: |
          TAG_NAME=${GITHUB_REF#refs/tags/}
          # Permitimos vX.Y.Z o vX.Y.Z.W
          if [[ ! "$TAG_NAME" =~ ^v[0-9]+\.[0-9]+\.[0-9]+(\.[0-9]+)?$ ]]; then
            echo "❌ El tag '$TAG_NAME' no es una versión semántica válida."
            echo "   Debe tener el formato 'vMAJOR.MINOR.PATCH' o 'vMAJOR.MINOR.PATCH.BUILD', por ejemplo v1.2.3 o v1.2.3.4"
            exit 1
          fi
          echo "✅ Tag válido: $TAG_NAME"

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ vars.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Wait for MongoDB
        run: |
          echo "Waiting for MongoDB to start..."
          i=0
          # Intenta conectar al puerto 27017 de localhost hasta 30 veces
          until nc -z localhost 27017; do
            i=$((i+1))
            if [ $i -ge 30 ]; then
              echo "$(date) - MongoDB service timed out."
              exit 1
            fi
            echo "$(date) - Waiting for MongoDB service... ($i/30)"
            sleep 1
          done
          echo "MongoDB started!"

      - name: Run linter
        run: npm run lint

      - name: Run tests
        run: npm run test

      - name: Run e2e tests
        env:
          MONGODB_URI: mongodb://localhost:27017/test_db
        run: npm run test:e2e

  check-ecr-and-create:
    name: Check and Create ECR Repository
    runs-on: ubuntu-latest
    needs: test-and-lint
    outputs:
      repository_exists: ${{ steps.check-repo.outputs.exists }}
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ vars.AWS_REGION }}

      - name: Check if ECR repository exists
        id: check-repo
        env:
          ECR_REPOSITORY: ${{ env.ECR_REPOSITORY }}
        run: |
          echo "Checking for ECR repository: $ECR_REPOSITORY"
          if aws ecr describe-repositories --repository-names "$ECR_REPOSITORY" > /dev/null 2>&1; then
            echo "Repository exists"
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "Repository does not exist"
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Checkout Terraform Code
        uses: actions/checkout@v4
        with:
          repository: 'jaimeshalom/aws-terraform'
          path: './terraform-infra' # Directorio donde se descargará el código
          # token: ${{ secrets.TERRAFORM_REPO_PAT }} # Añade esto si el repo Terraform es privado

      - name: Setup Terraform
        if: steps.check-repo.outputs.exists == 'false'
        uses: hashicorp/setup-terraform@v3

      - name: Terraform Init
        if: steps.check-repo.outputs.exists == 'false'
        id: init
        run: terraform init -input=false
        working-directory: ./terraform-infra

      - name: Terraform Validate
        if: steps.check-repo.outputs.exists == 'false'
        id: validate
        run: terraform validate -no-color
        working-directory: ./terraform-infra

      - name: Terraform Plan
        if: steps.check-repo.outputs.exists == 'false'
        id: plan
        run: |
          terraform plan -input=false -no-color \
            -var="image_tag=latest" \
            -var="aws_region=${{ vars.AWS_REGION }}" \
            -var="project_name=${{ vars.PROJECT_NAME }}" \
            -var="environment=${{ vars.ENVIRONMENT }}" \
            -var="owner=${{ vars.OWNER }}" \
            -var="mongodb_uri=${{ secrets.MONGODB_URI }}" \
            -out=tfplan
        working-directory: ./terraform-infra
        # continue-on-error: true # Para ver el plan incluso si falla

      - name: Terraform Apply
        if: steps.check-repo.outputs.exists == 'false'
        # Puedes añadir condiciones, como sólo aplicar si el plan fue exitoso
        # if: steps.plan.outcome == 'success'
        run: terraform apply -auto-approve -input=false tfplan
        working-directory: ./terraform-infra

  create-docker-image:
    name: Build and Push Image
    runs-on: ubuntu-latest
    needs: check-ecr-and-create
    outputs:
      image_tag: ${{ steps.build-push.outputs.image_tag }}
      image_version: ${{ steps.build-push.outputs.image_version }} # El tag vX.Y.Z para metadata
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ vars.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build, tag, and push image with multiple tags
        id: build-push
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          GIT_BRANCH: ${{ github.ref_name }}
          COMMIT_SHA: ${{ github.sha }}
          ECR_REPOSITORY: ${{ env.ECR_REPOSITORY }}
        run: |
          # Sanitización del tag (v*.*.* ya cumple con las reglas de Docker)
          SANITIZED_TAG=$(echo "$GIT_BRANCH" | tr -cd '[:alnum:]-._' | sed 's/^[.-]*//' | cut -c 1-50)

          # Tags definitivos
          BASE_TAG="$ECR_REGISTRY/$ECR_REPOSITORY"
          TAG_SHA="$BASE_TAG:${COMMIT_SHA}-${GITHUB_RUN_ID}"
          TAG_VERSION="$BASE_TAG:$SANITIZED_TAG"

          docker build -t "$TAG_SHA" -t "$TAG_VERSION" .
          docker push "$TAG_SHA"
          docker push "$TAG_VERSION"

          # Output para el deploy
          echo "image_tag=${COMMIT_SHA}-${GITHUB_RUN_ID}" >> $GITHUB_OUTPUT
          echo "image_version=$SANITIZED_TAG" >> $GITHUB_OUTPUT

  deploy-infra:
    name: Deploy Infrastructure with Terraform
    runs-on: ubuntu-latest
    needs: create-docker-image
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ vars.AWS_REGION }}

      - name: Checkout Terraform Code
        uses: actions/checkout@v4
        with:
          repository: 'jaimeshalom/aws-terraform'
          path: './terraform-infra' # Directorio donde se descargará el código
          # token: ${{ secrets.TERRAFORM_REPO_PAT }} # Añade esto si el repo Terraform es privado

      # 3. Setup Terraform
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        # Puedes fijar una versión si es necesario
        # with:
        #   terraform_version: 1.6.x

      # 4. Terraform Init (en el directorio del código Terraform)
      - name: Terraform Init
        id: init
        run: terraform init -input=false
        working-directory: ./terraform-infra # Especifica el directorio

      # 5. Terraform Validate (Opcional pero bueno)
      - name: Terraform Validate
        id: validate
        run: terraform validate -no-color
        working-directory: ./terraform-infra

      # 6. Terraform Plan (Opcional pero recomendado)
      - name: Terraform Plan
        id: plan
        run: |
          terraform plan -input=false -no-color \
            -var="image_tag=${{ needs.create-docker-image.outputs.image_tag }}" \
            -var="git_version_tag=${{ needs.create-docker-image.outputs.image_version }}" \
            -var="aws_region=${{ vars.AWS_REGION }}" \
            -var="project_name=${{ vars.PROJECT_NAME }}" \
            -var="environment=${{ vars.ENVIRONMENT }}" \
            -var="owner=${{ vars.OWNER }}" \
            -var="mongodb_uri=${{ secrets.MONGODB_URI }}" \
            -out=tfplan
        working-directory: ./terraform-infra
        # continue-on-error: true # Para ver el plan incluso si falla

      # 7. Terraform Apply (¡Aquí se aplica!)
      - name: Terraform Apply
        # Puedes añadir condiciones, como sólo aplicar si el plan fue exitoso
        # if: steps.plan.outcome == 'success'
        run: terraform apply -auto-approve -input=false tfplan
        working-directory: ./terraform-infra
        # --- Alternativa si no guardaste el plan ---
        # run: |
        #  terraform apply -auto-approve -input=false \
        #    -var="image_tag=${{ needs.create-docker-image.outputs.image_tag }}" \
        #    -var="aws_region=${{ vars.AWS_REGION }}" \
        #    -var="project_name=${{ vars.PROJECT_NAME }}" \
        #    -var="environment=${{ vars.ENVIRONMENT }}" \
        #    -var="owner=${{ vars.OWNER }}" \
        #    -var="mongodb_uri=${{ secrets.MONGODB_URI }}"
        # working-directory: ./terraform-infra
